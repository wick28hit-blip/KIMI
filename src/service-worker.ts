/// <reference lib="webworker" />
import { cleanupOutdatedCaches, precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { ExpirationPlugin } from 'workbox-expiration';
import { checkPeriodicNotifications } from './utils/scheduler';

declare let self: ServiceWorkerGlobalScope & { __WB_MANIFEST: any };

// 1. Precache Local Assets (Generated by VitePWA)
cleanupOutdatedCaches();
precacheAndRoute(self.__WB_MANIFEST);

// 2. Cache External Dependencies (ESM.sh for React, etc.)
// Critical for offline usage in environments relying on Import Maps
registerRoute(
  ({ url }) => url.origin === 'https://esm.sh',
  new CacheFirst({
    cacheName: 'esm-cdn-cache',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({ maxEntries: 50, maxAgeSeconds: 30 * 24 * 60 * 60 }) // 30 Days
    ]
  })
);

// 3. Cache Tailwind CDN
registerRoute(
  ({ url }) => url.origin === 'https://cdn.tailwindcss.com',
  new CacheFirst({
    cacheName: 'tailwind-cdn-cache',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({ maxEntries: 1, maxAgeSeconds: 30 * 24 * 60 * 60 })
    ]
  })
);

// 4. Cache Google Fonts (Stylesheets)
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// 5. Cache Google Fonts (Font Files)
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({ maxEntries: 30, maxAgeSeconds: 365 * 24 * 60 * 60 })
    ]
  })
);

// 6. Install & Activate
self.addEventListener('install', (event) => {
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  event.waitUntil(self.clients.claim());
});

// 7. Periodic Sync
self.addEventListener('periodicsync', (event: any) => {
  if (event.tag === 'kimi-pms-notification-sync') {
    event.waitUntil(checkPeriodicNotifications());
  }
});

// 8. Message Handler
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'CHECK_NOTIFICATIONS') {
    checkPeriodicNotifications();
  }
});

// 9. Notification Click
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      if (clientList.length > 0) {
        let client = clientList[0];
        for (let i = 0; i < clientList.length; i++) {
          if (clientList[i].focused) {
            client = clientList[i];
          }
        }
        return client.focus();
      }
      return self.clients.openWindow('/');
    })
  );
});
